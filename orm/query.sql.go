// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: query.sql

package orm

import (
	"context"
)

const findTask = `-- name: FindTask :one
select id, mode, stg_hash, create_at, start_at, stop_at, info from bottask
where mode = $1
and stg_hash = $2
order by create_at desc
limit 1
`

type FindTaskParams struct {
	Mode    string
	StgHash string
}

func (q *Queries) FindTask(ctx context.Context, arg FindTaskParams) (Bottask, error) {
	row := q.db.QueryRow(ctx, findTask, arg.Mode, arg.StgHash)
	var i Bottask
	err := row.Scan(
		&i.ID,
		&i.Mode,
		&i.StgHash,
		&i.CreateAt,
		&i.StartAt,
		&i.StopAt,
		&i.Info,
	)
	return i, err
}

const getExOrders = `-- name: GetExOrders :many
select id, task_id, inout_id, symbol, enter, order_type, order_id, side, create_at, price, average, amount, filled, status, fee, fee_type, update_at from exorder
where inout_id=$1
`

func (q *Queries) GetExOrders(ctx context.Context, inoutID int32) ([]Exorder, error) {
	rows, err := q.db.Query(ctx, getExOrders, inoutID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exorder
	for rows.Next() {
		var i Exorder
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.InoutID,
			&i.Symbol,
			&i.Enter,
			&i.OrderType,
			&i.OrderID,
			&i.Side,
			&i.CreateAt,
			&i.Price,
			&i.Average,
			&i.Amount,
			&i.Filled,
			&i.Status,
			&i.Fee,
			&i.FeeType,
			&i.UpdateAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIOrder = `-- name: GetIOrder :one
select id, task_id, symbol, sid, timeframe, short, status, enter_tag, init_price, quote_cost, exit_tag, leverage, enter_at, exit_at, strategy, stg_ver, profit_rate, profit, info from iorder
where id = $1
`

func (q *Queries) GetIOrder(ctx context.Context, id int64) (Iorder, error) {
	row := q.db.QueryRow(ctx, getIOrder, id)
	var i Iorder
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Symbol,
		&i.Sid,
		&i.Timeframe,
		&i.Short,
		&i.Status,
		&i.EnterTag,
		&i.InitPrice,
		&i.QuoteCost,
		&i.ExitTag,
		&i.Leverage,
		&i.EnterAt,
		&i.ExitAt,
		&i.Strategy,
		&i.StgVer,
		&i.ProfitRate,
		&i.Profit,
		&i.Info,
	)
	return i, err
}

const getKRange = `-- name: GetKRange :one
select start, stop from kinfo
where sid = $1
and timeframe = $2
limit 1
`

type GetKRangeParams struct {
	Sid       int64
	Timeframe string
}

type GetKRangeRow struct {
	Start int64
	Stop  int64
}

func (q *Queries) GetKRange(ctx context.Context, arg GetKRangeParams) (GetKRangeRow, error) {
	row := q.db.QueryRow(ctx, getKRange, arg.Sid, arg.Timeframe)
	var i GetKRangeRow
	err := row.Scan(&i.Start, &i.Stop)
	return i, err
}

const getTask = `-- name: GetTask :one
select id, mode, stg_hash, create_at, start_at, stop_at, info from bottask
where id = $1
`

func (q *Queries) GetTask(ctx context.Context, id int64) (Bottask, error) {
	row := q.db.QueryRow(ctx, getTask, id)
	var i Bottask
	err := row.Scan(
		&i.ID,
		&i.Mode,
		&i.StgHash,
		&i.CreateAt,
		&i.StartAt,
		&i.StopAt,
		&i.Info,
	)
	return i, err
}

const listKHoles = `-- name: ListKHoles :many
select id, sid, timeframe, start, stop from khole
`

func (q *Queries) ListKHoles(ctx context.Context) ([]Khole, error) {
	rows, err := q.db.Query(ctx, listKHoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Khole
	for rows.Next() {
		var i Khole
		if err := rows.Scan(
			&i.ID,
			&i.Sid,
			&i.Timeframe,
			&i.Start,
			&i.Stop,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listKInfos = `-- name: ListKInfos :many
select sid, timeframe, start, stop from kinfo
`

func (q *Queries) ListKInfos(ctx context.Context) ([]Kinfo, error) {
	rows, err := q.db.Query(ctx, listKInfos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Kinfo
	for rows.Next() {
		var i Kinfo
		if err := rows.Scan(
			&i.Sid,
			&i.Timeframe,
			&i.Start,
			&i.Stop,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSymbols = `-- name: ListSymbols :many
select id, exchange, symbol, market, list_dt, delist_dt from symbol
where exchange = $1
and market = $2
order by id
`

type ListSymbolsParams struct {
	Exchange string
	Market   string
}

func (q *Queries) ListSymbols(ctx context.Context, arg ListSymbolsParams) ([]Symbol, error) {
	rows, err := q.db.Query(ctx, listSymbols, arg.Exchange, arg.Market)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Symbol
	for rows.Next() {
		var i Symbol
		if err := rows.Scan(
			&i.ID,
			&i.Exchange,
			&i.Symbol,
			&i.Market,
			&i.ListDt,
			&i.DelistDt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTaskPairs = `-- name: ListTaskPairs :many
select symbol from iorder
where task_id = $1
and enter_at >= $2
and enter_at <= $3
`

type ListTaskPairsParams struct {
	TaskID    int32
	EnterAt   int64
	EnterAt_2 int64
}

func (q *Queries) ListTaskPairs(ctx context.Context, arg ListTaskPairsParams) ([]string, error) {
	rows, err := q.db.Query(ctx, listTaskPairs, arg.TaskID, arg.EnterAt, arg.EnterAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var symbol string
		if err := rows.Scan(&symbol); err != nil {
			return nil, err
		}
		items = append(items, symbol)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
select id, mode, stg_hash, create_at, start_at, stop_at, info from bottask
order by id
`

func (q *Queries) ListTasks(ctx context.Context) ([]Bottask, error) {
	rows, err := q.db.Query(ctx, listTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bottask
	for rows.Next() {
		var i Bottask
		if err := rows.Scan(
			&i.ID,
			&i.Mode,
			&i.StgHash,
			&i.CreateAt,
			&i.StartAt,
			&i.StopAt,
			&i.Info,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
